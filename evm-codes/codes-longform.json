[
  {
    "opcode": "00",
    "name": "STOP",
    "mingas": "0",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "Exits the current context successfully.\n\nWhen a call is executed on an address with no code and the EVM tries to read the code data, the default value is returned, 0, which corresponds to the this instruction and halts the execution."
  },
  {
    "opcode": "01",
    "name": "ADD",
    "mingas": "3",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "first integer value to add",
      "b": "second integer value to add"
    },
    "output": {
      "a + b": "integer result of the addition modulo 2^256."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "02",
    "name": "MUL",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "first integer value to multiply.",
      "b": "second integer value to multiply."
    },
    "output": {
      "a * b": "integer result of the multiplication modulo 2^256."
    },
    "errors": "The state changes done by the current context are reverted int he following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "03",
    "name": "SUB",
    "mingas": "3",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "first integer value.",
      "b": "integer value to subtract from the first."
    },
    "output": {
      "a - b": "integer result of the subtraction modulo 2^256"
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "04",
    "name": "DIV",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a / b": "integer result of the integer division. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "05",
    "name": "SDIV",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All values are treated as two's complement signed 256-bit integers. Note the overflow semantic when -2^256 is negated.",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a / b": "integer result of the signed integer division. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "06",
    "name": "MOD",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a % b": "integer result of the integer modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "07",
    "name": "SMOD",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All values are treated as two's complement signed 256-bit integers. Note the overflow semantic when -2^256 is negated.",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a % b": "integer result of the signed integer modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "08",
    "name": "ADDMOD",
    "mingas": "8",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All intermediate calculations of this operation are not subject to the 2^256 modulo.",
    "input": {
      "a": "first integer value to add.",
      "b": "second integer value to add.",
      "N": "integer denominator."
    },
    "output": {
      "(a + b) % N": "integer result of the addition followed by a modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "09",
    "name": "MULMOD",
    "mingas": "8",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All intermediate calculations of this operation are not subject to the 2^256 modulo.",
    "input": {
      "a": "the first integer value to multiply.",
      "b": "second integer value to multiply.",
      "N": "integer denominator."
    },
    "output": {
      "(a * b) % N": "integer result of the multiplication followed by a modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "0A",
    "name": "EXP",
    "mingas": "10",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "integer base.",
      "b": "integer exponent."
    },
    "output": {
      "a ** b": "integer result of the exponential operation modulo 2^256."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "OB",
    "name": "SIGNEXTEND",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "b": "size in byte -1 of the integer to sign extend.",
      "x": "integer value to sign extend."
    },
    "output": {
      "y": "integer result of the sign extend."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "10",
    "name": "LT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "left side integer.",
      "b": "right side integer."
    },
    "output": {
      "a < b": "1 if the left side is smaller, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "11",
    "name": "GT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "left side integer.",
      "b": "right side integer."
    },
    "output": {
      "a > b": "1 if the left side is bigger, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "12",
    "name": "SLT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "notes": "All values are treated as two's complement signed 256-bit integers.",
    "input": {
      "a": "left side signed integer",
      "b": "right side signed integer."
    },
    "output": {
      "a < b": "1 if the left side is smaller, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "13",
    "name": "SGT",
    "mingas": "6",
    "since": "frontier",
    "group": "comparison&bitwise",
    "notes": "All values are treated as two's complements signed 256-bit integers.",
    "input": {
      "a": "left side signed integer.",
      "b": "right side signed integer."
    },
    "output": {
      "a < b": "1 if the left side is bigger, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "14",
    "name": "EQ",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "left side integer.",
      "b": "right side integer."
    },
    "output": {
      "a == b": "1 if the left side equal to the right side, 0 otherwise"
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "15",
    "name": "ISZERO",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "integer."
    },
    "output": {
      "a == 0": "1 if a is 0, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "16",
    "name": "AND",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "first brinary value.",
      "b": "second binary value."
    },
    "output": {
      "a & b": "the bitwise AND result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "17",
    "name": "OR",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "first brinary value.",
      "b": "second binary value."
    },
    "output": {
      "a | b": "the bitwise OR result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "18",
    "name": "XOR",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "first brinary value.",
      "b": "second binary value."
    },
    "output": {
      "a ^ b": "the bitwase XOR result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "19",
    "name": "NOT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "binary value."
    },
    "output": {
      "~a": "the bitwase NOT result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "1A",
    "name": "BYTE",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "i": "byte offset starting from the most significant bytes.",
      "x": "32-bytes value."
    },
    "output": {
      "y": "the indicated bytes at the least significant position. If the bytes offset is out of range, the result is 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "1B",
    "name": "SHL",
    "mingas": "3",
    "since": "constantinople",
    "group": "comparison&bitwise",
    "notes": "Shift the bits towards the most significant one. The bits moved after the 256th one are discarded, the new bits are set to 0.",
    "input": {
      "shift": "number of bits to shift to the left.",
      "value": "32 bytes to shift."
    },
    "output": {
      "value << shift": "the shifted value. If shift is bigger than 255, returns 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "1C",
    "name": "SHR",
    "mingas": "3",
    "since": "constantinople",
    "group": "comparison&bitwise",
    "notes": "Shifts the bit towards the least significant one. The bits moved before the first one are discarded, the new bits are set to 0.",
    "input": {
      "shift": "number of bits to shift to the right.",
      "value": "32 bytes to shift."
    },
    "output": {
      "value >> shift": "the shifted value. If shift is bigger than 255, returns 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcodes": "1D",
    "name": "SAR",
    "mingas": "3",
    "since": "constantinople",
    "group": "comparison&bitwise",
    "notes": "Shift the bits towards the least significant one. The bits moved before the first one are discarded, the new bits are set to 0 if the previous most significant bit was 0, otherwise the new bits are set to 1.",
    "input": {
      "shift": "number of bits to shift to the right.",
      "value": "integer to shift."
    },
    "output": {
      "value >> shift": "the shifted value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "20",
    "name": "SHA3",
    "mingas": "30",
    "since": "frontier",
    "group": "SHA3",
    "input": {
      "offset": "byte offset in the memory.",
      "size": "byte size to read in the memory."
    },
    "output": {
      "hash": "Keccak-256 hash of the given data in memory."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "30",
      "dynamic_gas": "6 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "30",
    "name": "ADDRESS",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "address": "the 20-byte address of the current account."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "31",
    "name": "BALANCE",
    "mingas": "100",
    "since": "frontier",
    "group": "environmentalinfo",
    "input": {
      "address": "the 20-byte address of the current account."
    },
    "output": {
      "balance": "balance of the given account in wei. Returns 0 if the account doesn't exist."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": "The static cost is 0. if the accessed address is warm, the dynamic cost is 100. Otherwise the dynamic cost is 2600."
  },
  {
    "opcode": "32",
    "name": "ORIGIN",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "address": "the 20-byte address of the sender of the transaction. It can only be an account without code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "33",
    "name": "CALLER",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "address": "the 20-byte address of the caller account. This is the account that did the last call (except delegate call)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "34",
    "name": "CALLVALUE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "value": "the value of the current call in wei."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "35",
    "name": "CALLDATALOAD",
    "mingas": "3",
    "since": "frontier",
    "group": "environmentalinfo",
    "input": {
      "i": "byte offset in the calldata."
    },
    "output": {
      "data[i]": "32-byte value starting from the given offset of the calldata. All bytes after end of the calldata are set to 0."
    },
    "gas": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "36",
    "name": "CALLDATASIZE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "size": "byte size of the calldata."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "37",
    "name": "CALLDATACOPY",
    "mingas": "3",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "For out of bound bytes, 0s will be copied",
    "input": {
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the calldata to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "3",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "38",
    "name": "CODESIZE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "Each instruction occupies on byte. In the case of a PUSH instruction, the bytes that need to be pushed are encoded after that, it thus increases the codesize accordingly.",
    "output": {
      "size": "byte size of the code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "39",
    "name": "CODECOPY",
    "mingas": "3",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "For out of bounds bytes, 0s will be copied.",
    "input": {
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the code to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "3",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "3A",
    "name": "GASPRICE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "price": "gas price in wei per gas."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "3B",
    "name": "EXTCODESIZE",
    "mingas": "100",
    "since": "frontier",
    "group": "environmentalinfo",
    "input": {
      "address": "20-byte address of the contract to query."
    },
    "output": {
      "size": "byte size of the code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": "The static cost is 0. If the accessed address is warm, the dynamic cost is 100. Otherwise the dynamic cost is 2600."
  },
  {
    "opcode": "3C",
    "name": "EXTCODECOPY",
    "mingas": "100",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "For out of bounds bytes, 0s will be copied.",
    "input": {
      "address": "20-byte address of the contract to query.",
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the code to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "0",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost + address_access_cost",
      "notes": "If the accessed address is warm, address_access_cost is 100, otherwise it is 2600."
    }
  },
  {
    "opcode": "3D",
    "name": "RETURNDATASIZE",
    "mingas": "2",
    "since": "byzantium",
    "group": "environmentalinfo",
    "notes": "A sub context can be created with CALL, CALLCODE, DELEGATECALL, or STATICCALL",
    "output": {
      "size": "byte size of the return data from the last executed sub context."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "3E",
    "name": "RETURNDATACOPY",
    "mingas": "3",
    "since": "byzantium",
    "group": "environmentalinfo",
    "notes": "A sub context can be creaed with CALL, CALLCODE, DELEGATECALL, or STATICCALL.",
    "input": {
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the return data from the last executed sub context to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nReading offset equal or higher than RETURNDATASIZE.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "3",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "3F",
    "name": "EXTCODEHASH",
    "mingas": "100",
    "since": "constantinople",
    "group": "environmentalinfo",
    "input": {
      "address": "20-byte address of the account."
    },
    "output": {
      "hash": "hash of the chosen account's code, or 0 if the account has no code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": "The static cost is 0. If the accessed address is warm, the dynamic cost is 100. Otherwise the dynamic cost is 2600."
  },
  {
    "opcode": "40",
    "name": "BLOCKHASH",
    "mingas": "20",
    "since": "frontier",
    "group": "blockinfo",
    "input": {
      "blockNumber": "block number to get the hash from. Valid range is the last 256 blocks (not including the current one). Current block number can be queried with NUMBER."
    },
    "output": {
      "hash": "hash of the chosen block, or 0 if the block number is not in the valid range."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "41",
    "name": "COINBASE",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "address": "miner's 20-byte address."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "42",
    "name": "TIMESTAMP",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "timestamp": "unix timestamp of the current block"
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "43",
    "name": "NUMBER",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "blockNumber": "current block number."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "44",
    "name": "DIFFICULTY",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "difficulty": "current block difficulty"
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "45",
    "name": "GASLIMIT",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "gasLimit": "gas limit."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "46",
    "name": "CHAINID",
    "mingas": "2",
    "since": "istanbul",
    "group": "blockinfo",
    "notes": {
      "1": "Mainnet",
      "3": "Ropsten",
      "4": "Rinkeby",
      "5": "Goerli",
      "6": "Kotti",
      "61": "Classic",
      "63": "Mordor",
      "212": "Astor",
      "2018": "Dev"
    },
    "output": {
      "chainId": "chain id of the network."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "47",
    "name": "SELFBALANCE",
    "mingas": "5",
    "since": "istanbul",
    "group": "blockinfo",
    "notes": "Semantically equivalent of calling BALANCE with ADDRESS as paramater, but with a reduced gas cost.",
    "output": {
      "balance": "balance of the current account in wei."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "48",
    "name": "BASEFEE",
    "mingas": "2",
    "since": "london",
    "group": "blockinfo",
    "output": {
      "baseFee": "base fee in wei."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "50",
    "name": "POP",
    "mingas": "2",
    "since": "frontier",
    "group": "stack&flow",
    "input": {
      "y": "a stack item."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "51",
    "name": "MLOAD",
    "mingas": "3",
    "since": "frontier",
    "group": "stack&flow",
    "input": {
      "offset": "offset in the memory in bytes."
    },
    "output": {
      "value": "the 32 bytes in memory starting at that offset. If it goes beyond its current size, writes 0s."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "static_gas": "3",
      "dynamic_gas": "memory_expansion_cost"
    }
  },
  {
    "opcode": "52",
    "name": "MSTORE",
    "mingas": "3",
    "since": "frontier",
    "group": "stack&flow",
    "input": {
      "offset": "offset in the memory in bytes.",
      "value": "32-byte value to write in the memory."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "static_gas": "3",
      "dynamic_gas": "memory_expansion_cost"
    }
  },
  {
    "opcode": "53",
    "name": "MSTORE8",
    "mingas": "3",
    "since": "frontier",
    "group": "stack&flow",
    "input": {
      "offset": "offset in the memory in bytes.",
      "value": "1-byte value to write in the memory (the least significant byte of the 32-byte stack value)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "static_gas": "3",
      "dynamic_gas": "memory_expansion_cost"
    }
  },
  {
    "opcode": "54",
    "name": "SLOAD",
    "mingas": "100",
    "since": "frontier",
    "group": "stack&flow",
    "input": {
      "key": "32-byte key in storage."
    },
    "output": {
      "value": "32-byte value corresponding to that key. 0 if that key was never written before."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": "The static cost is 0. If the accessed address is warm, the dynamic cost is 100. Otherwise the dynamic cost is 2100."
  },
  {
    "opcode": "55",
    "name": "SSTORE",
    "mingas": "100",
    "since": "frontier",
    "group": "stack&flow",
    "input": {
      "key": "32-byte key in storage.",
      "value": "32-byte value to store."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current exeuction context is from a STATICCALL (since Byzantium fork).",
    "gas": {
      "definitions": {
        "value": "value from the stack input.",
        "current_value": "current value of the storage slot.",
        "original_value": "value of the storage slot before the current transaction."
      },
      "static_gas": "0",
      "logic": "if (value == current_value) { if (key is warm) { base_dynamic_gas = 100 } else { base_dynamic_gas = 100 } else if } else if (current_value == original_value) { if (original_value == 0) { base_dynamic_gas = 20000 } else { base_dynamic_gas = 2900 } } else { base_dynamic_gas = 100 }",
      "notes": "Additionally, 2100 is added to the base_dynamic_gas if the slot is cold."
    },
    "refunds": {
      "logic": "if(value!=current_value){if(current_value==original_value){if(original_value!=0andvalue==0){gas_refunds+=4800}}else{if(original_value!=0){if(current_value==0){gas_refunds-=4800}elseif(value==0){gas_refunds+=4800}}if(value==original_value){if(original_value==0){if(keyiswarm){gas_refunds+=20000-100}else{gas_refunds+=19900}}else{if(keyiswarm){gas_refunds+=5000-2100-100}else{gas_refunds+=4900}}}}}"
    }
  },
  {
    "opcode": "56",
    "name": "JUMP",
    "mingas": "8",
    "since": "frontier",
    "group": "stack&flow",
    "notes": "The program counter is a byte offset in the deployed code. It indicates which instruction will be executed next. When an ADD is executed, for example, the PC is incremented by 1, since the instruction is 1 byte. The  PUSH instruction are bigger than one byte, and so will increment the counter accordingly.\n\nThe JUMP instruction alters the program counter, thus breaking the linear path of the execution to another point in the deployed code. It is used to implement functionalities like functions.",
    "input": {
      "counter": "byte offset in the deployed code where execution will continue from. Must be a JUMPDEST instruction."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nCounter offset is not a JUMPDEST. The error is generated even if the JUMP would not have been done."
  },
  {
    "opcode": "57",
    "name": "JUMPI",
    "mingas": "10",
    "since": "frontier",
    "group": "stack&flow",
    "notes": "The program counter (PC) is a byte offset in the deployed code. It indicates which instruction will be executed next. When an ADD is executed, for example, the PC is incremented by 1, since the instruction is 1 byte. The PUSH instructions are bigger than one byte, so will increment the counter accordingly.\n\nThe JUMPI instruction may alter the program counter, thus breaking the linear path of the execution to another point in the deployed code. It is used to implement functionalities like loops and conditions.",
    "input": {
      "counter": "byte offset in the deployed code where execution will continue from. Must be a JUMPDEST instruction.",
      "b": "the program counter will be altered with the new value only if this value is different from 0. Otherwise, the program counter is simply incremented and the next instruction will be executed.",
      "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nCounter offset is not a JUMPDEST. The error is generated only if the JUMP would have been done."
    }
  },
  {
    "opcode": "58",
    "name": "PC",
    "mingas": "2",
    "since": "frontier",
    "group": "stack&flow",
    "notes": "The program counter is a byte offset in the deployed code. It indicates which instruction will be executed next. When an ADD is executed, for example, the PC is incremented by 1, since the instruction is 1 byte. The PUSH instructions are bigger than one byte, and so will increment the counter accordingly",
    "output": {
      "counter": "Program counter of this instruction is the current program."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "59",
    "name": "MSIZE",
    "mingas": "2",
    "since": "frontier",
    "group": "stack&flow",
    "notes": "The memory is always fully accessible. What this instruction tracks is the highest offset that was accessed in the current exeuction. A first write or read to a bigger offset will trigger a memory expansion, which will cost gas. The size is always a multiple of a word (32 bytes).",
    "output": {
      "size": "current memory size in bytes (higher offset accessed until now + 1)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "5A",
    "name": "GAS",
    "mingas": "2",
    "since": "frontier",
    "group": "stack&flow",
    "output": {
      "gas": "remaining gas (after this instruction)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "5B",
    "name": "JUMPDEST",
    "mingas": "1",
    "since": "frontier",
    "group": "stack&flow",
    "notes": "Mark a valid destination for JUMP or JUMPI. This operation has no effect on machine state during execution."
  },
  {
    "opcode": "60",
    "name": "PUSH1",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed would have to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "61",
    "name": "PUSH2",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indicies. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed would have to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "62",
    "name": "PUSH3",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for the specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed would have to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "63",
    "name": "PUSH4",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The value for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed would have to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "64",
    "name": "PUSH5",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "65",
    "name": "PUSH6",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "66",
    "name": "PUSH7",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "67",
    "name": "PUSH8",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "68",
    "name": "PUSH9",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "69",
    "name": "PUSH10",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "6A",
    "name": "PUSH11",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "6B",
    "name": "PUSH12",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "6C",
    "name": "PUSH13",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "6D",
    "name": "PUSH14",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "6E",
    "name": "PUSH15",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "6F",
    "name": "PUSH16",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "70",
    "name": "PUSH17",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "71",
    "name": "PUSH18",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "72",
    "name": "PUSH19",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "73",
    "name": "PUSH20",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "74",
    "name": "PUSH21",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "75",
    "name": "PUSH22",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "76",
    "name": "PUSH23",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "77",
    "name": "PUSH24",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "78",
    "name": "PUSH25",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "79",
    "name": "PUSH26",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "7A",
    "name": "PUSH27",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "7B",
    "name": "PUSH28",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "7C",
    "name": "PUSH29",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "7D",
    "name": "PUSH30",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "7E",
    "name": "PUSH31",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "7F",
    "name": "PUSH32",
    "mingas": "3",
    "since": "frontier",
    "group": "pushops",
    "notes": "The new value is put on top of the stack, incrementing all the other value indices. The values for a specific opcode thus have to be pushed in reverse order of the stack. For example, with MSTORE, the first value pushed woul dhave to be value, and then offset.",
    "output": {
      "value": "pushed value, aligned to the right (put in the lowest significant bytes)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "80",
    "name": "DUP1",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "value": "value to duplicate."
    },
    "output": {
      "a": "duplicated value.",
      "b": "orignal value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "81",
    "name": "DUP2",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "a": "ignored value.",
      "b": "value to duplicate."
    },
    "output": {
      "a": "duplicated value.",
      "b": "ignored value.",
      "c": "original value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "82",
    "name": "DUP3",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "a": "ignored value.",
      "b": "ignored value.",
      "c": "value to duplicate."
    },
    "output": {
      "c": "duplicated value.",
      "a": "ignored value.",
      "b": "ignored value.",
      "d": "original value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "83",
    "name": "DUP4",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "value": "value to duplicate."
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "b": "origial value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "84",
    "name": "DUP5",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "value": "value to duplicate."
    },
    "output": {
      "a": "duplicated",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "85",
    "name": "DUP6",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "86",
    "name": "DUP7",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "value": "value to duplicate."
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "87",
    "name": "DUP8",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "88",
    "name": "DUP9",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "89",
    "name": "DUP10",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "8A",
    "name": "DUP11",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "8B",
    "name": "DUP12",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "8C",
    "name": "DUP13",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "8D",
    "name": "DUP14",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "8E",
    "name": "DUP15",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "15": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "8F",
    "name": "DUP16",
    "mingas": "3",
    "since": "frontier",
    "group": "duplicationops",
    "input": {
      "1": "ignored value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "15": "ignored value.",
      "value": "value to duplicate"
    },
    "output": {
      "a": "duplicated value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "15": "ignored value.",
      "b": "original value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nStack overflow."
  },
  {
    "opcode": "90",
    "name": "SWAP1",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "91",
    "name": "SWAP2",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "b": "ignored value.",
      "c": "value to swap."
    },
    "output": {
      "c": "swapped value.",
      "b": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "92",
    "name": "SWAP3",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "93",
    "name": "SWAP4",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "94",
    "name": "SWAP5",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "95",
    "name": "SWAP6",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "96",
    "name": "SWAP7",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "97",
    "name": "SWAP8",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "98",
    "name": "SWAP9",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "99",
    "name": "SWAP10",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "9A",
    "name": "SWAP11",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "9B",
    "name": "SWAP12",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "9C",
    "name": "SWAP13",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "9D",
    "name": "SWAP14",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "9E",
    "name": "SWAP15",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "15": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "15": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "9F",
    "name": "SWAP16",
    "mingas": "3",
    "since": "frontier",
    "group": "exchangeops",
    "input": {
      "a": "value to swap.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "15": "ignored value.",
      "16": "ignored value.",
      "b": "value to swap."
    },
    "output": {
      "b": "swapped value.",
      "2": "ignored value.",
      "3": "ignored value.",
      "4": "ignored value.",
      "5": "ignored value.",
      "6": "ignored value.",
      "7": "ignored value.",
      "8": "ignored value.",
      "9": "ignored value.",
      "10": "ignored value.",
      "11": "ignored value.",
      "12": "ignored value.",
      "13": "ignored value.",
      "14": "ignored value.",
      "15": "ignored value.",
      "16": "ignored value.",
      "a": "swapped value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "A0",
    "name": "LOG0",
    "mingas": "375",
    "since": "frontier",
    "group": "loggingops",
    "notes": "This instruction has no effect on the EVM state.",
    "input": {
      "offset": "byte offset int he memory in bytes.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current execution context is from a STATICCALL (since Byzantium fork).",
    "gas": {
      "static_gas": "375",
      "dynamic_gas": "375 * topic_count + 8 * size + memory_expansion_cost",
      "notes": "For LOG0, topic_count is 0."
    }
  },
  {
    "opcode": "A1",
    "name": "LOG1",
    "mingas": "750",
    "since": "frontier",
    "group": "loggingops",
    "notes": "This instruction has no effect on the EVM state.",
    "input": {
      "offset": "byte offset in the memory in bytes.",
      "size": "byte size to copy.",
      "topic1": "32-byte value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current exeuction context is from a STATICCALL (since Byzantium fork).",
    "gas": {
      "static_gas": "375",
      "dynamic_gas": "375 * topic_count + 8 * size + memory_expansion_cost",
      "notes": "For LOG1, topic_count is 1."
    }
  },
  {
    "opcode": "A2",
    "name": "LOG2",
    "mingas": "1125",
    "since": "frontier",
    "group": "loggingops",
    "notes": "This instruction has no effect on the EVM state.",
    "input": {
      "offset": "byte offset in the memory in bytes.",
      "size": "byte size to copy.",
      "topic1": "32-byte value.",
      "topic2": "32-byte value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current exeuction context is from a STATICCALL (since Byzantium fork)."
  },
  {
    "opcode": "A3",
    "name": "LOG3",
    "mingas": "1500",
    "since": "frontier",
    "group": "loggingops",
    "notes": "This instruction has no effect on the EVM state.",
    "input": {
      "offset": "byte offset in the memory in bytes.",
      "size": "byte size to copy.",
      "topic1": "32-byte value.",
      "topic2": "32-byte value.",
      "topic3": "32-byte value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current exeuction context is from a STATICCALL (since Byzantium fork).",
    "gas": {
      "static_gas": "375",
      "dynamic_gas": "375 * topic_count + 8 * size + memory_expansion_cost",
      "notes": "For LOG3, topic_count is 3."
    }
  },
  {
    "opcode": "A4",
    "name": "LOG4",
    "mingas": "1875",
    "since": "frontier",
    "group": "loggingops",
    "notes": "This instruction has no effect on the EVM state.",
    "input": {
      "offset": "byte offset in the memory in bytes.",
      "size": "byte size to copy.",
      "topic1": "32-byte value.",
      "topic2": "32-byte value.",
      "topic3": "32-byte value.",
      "topic4": "32-byte value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current exeuction context is from STATICCALL (since Byzantium fork).",
    "gas": {
      "static_gas": "375",
      "dynamic_gas": "375 * topic_count + 8 * size + memory_expansion_cost",
      "notes": "For LOG4, topic_count is 4."
    }
  },
  {
    "opcode": "F0",
    "name": "CREATE",
    "mingas": "32000",
    "since": "frontier",
    "group": "systemops",
    "notes": "Creates a new contract. Enters a new sub context of the calculated destination address and execute the provided initialization code, then resumes the current context.\n\nShould deployment succceed, the new account's code is set to the return data resulting from executing the initialization code.\n\nThe destination address is calculated as the rightmost 20 bytes (160 bits) of the Keccak-256 hash of the rlp encoding of the sender followed by its nonce.\n\naddress = keccak256(rlp([sender_address, sender_nonce]))[12:]\n\nDeployment can fail due to:\n\nInsufficient value to send.\nSub context reverted.\nInsufficient gas to execute the initialization code.\nCall depth limit reached.\n\nThese failures only affect the return value and do not cause the calling context to revert (unlike the error cases below).",
    "input": {
      "value": "value in wei to send to the new account.",
      "offset": "byte offset in the memory in bytes, the initalization code for the new account.",
      "size": "byte size to copy (size of the initalization code)."
    },
    "output": {
      "address": "the address of the deployed contract, 0 if the deployment failed."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current execution context is from a STATICCALL (since Byzantium fork).",
    "gas": {
      "code_deposit_cost": "200 * deployed_code_size",
      "static_gas": "32000",
      "dynamic_gas": "memory_expansion_cost + deployment_code_execution_cost + code_deposit_cost",
      "notes": "The deployment_code_execution_cost is the cost of whatever opcode is run to deploy the new contract. On top of that, there is an additional cost for storing the code of the new contract, shown as the code_deposit_cost.\n\nThe new contract address is added int he warm addresses."
    }
  },
  {
    "opcode": "F1",
    "name": "CALL",
    "mingas": "100",
    "since": "frontier",
    "group": "systemops",
    "notes": "Creates a new sub context and executes the code of the given account, then resumes the current one. Note that an account with no code will return success as true.\n\nIf the size of the return data is not known, it can also be retrieved after the call with the instructions RETURNDATASIZE and RETURNDATACOPY (since the Byzantium fork).\n\nFrom the Tangerine Whistle fork, gas is capped at all but one 64th (remaining_gas / 64) of the remaining gas of the current context. If a call tries to send more, the gas is changed to match the maximum allowed.",
    "input": {
      "gas": "amount of gas to send to the sub context to execute. The gas that is not used by the sub context is returned to this one.",
      "address": "the account which context to execute.",
      "value": "value in wei to send to the account.",
      "argsOffset": "byte offset in the memory in bytes, the calldata of the sub context.",
      "argsSize": "byte size to copy (size of the calldata).",
      "retOffset": "byte offset in the memory in bytes, where to store the return data of the sub context.",
      "retSize": "byte size to copy (size of the return data)."
    },
    "output": {
      "success": "return 0 if the sub context reverts, 1 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current execution context is from a STATICCALL and the value (stack index 2) is not 0 (since Byzantium fork)."
  },
  {
    "opcode": "F2",
    "name": "CALLCODE",
    "mingas": "100",
    "since": "frontier",
    "group": "systemops",
    "notes": "Creates a new sub context as if calling itself, but with the code of the given account. In particular the storage remains the same. Note that an account with no code will return as true.\n\nIf the size of the return data is not known, it can also be retrieved after the call with the instructions RETURNDATASIZE and RETURNDATACOPY (sinze the Byzantium fork).\n\nFrom the Tangerin Whistle fork, gas is capped at all but one 64th (remaining_gas / 64) of the remaining gas of the current context. If a call tries to send more, the gas is changed to match the maximum allowed.",
    "input": {
      "gas": "the amount of gas to send the sub context to execute. The gas that is not used by the sub context is returned to this one.",
      "address": "the account which code to execute.",
      "value": "value in wei to send to the account.",
      "argsOffset": "byte offset in the memory in bytes, the calldata of the sub context.",
      "argsSize": "byte size to copy (size of the calldata).",
      "retOffset": "byte offset in the memory in bytes, where to store the return data of the sub context.",
      "retSize": "byte size copy (size of the return data)."
    },
    "output": {
      "success": "return 0 if the sub context reverts, 1 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "static_gas": "0",
      "dynamic_gas": "memory_expansion_cost + code_execution_cost + address_access_cost + positive_value_cost",
      "notes": "The different costs are:\n\ncode_execution_cost is the cost of the called code execution (limited by the gas parameter).\nIf the address is warm, the address_access_cost is 100, otherwise it is 2600.\nIf the value is not 0, then positive_value_cost is 9000. In this case there is also a call stipend that is given to make sure that a basic fallback function can be called. 2300 is thus removed from the cost, and also added to the gas input."
    }
  },
  {
    "opcode": "F3",
    "name": "RETURN",
    "mingas": "0",
    "since": "frontier",
    "group": "systemops",
    "notes": "exits the current context succssfully.",
    "input": {
      "offset": "byte offset in the memory in bytes, to copy what will be the return data of this context.",
      "size": "byte size to copy (size of the return data)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "F4",
    "name": "DELEGATECALL",
    "mingas": "100",
    "since": "byzantium",
    "group": "systemops",
    "notes": "Creates a new sub context as if calling itself, but with the code of the given account. In particular the storage, the current sender and the current value remain the same. Note that an account with no code will return success as true.\n\nIf the size of the return data is not known, it can also be retrieved after the call with the instructions RETURNDATASIZE and RETURNDATACOPY (since the Byzantium fork).\n\nFrom the Tangerine Whistle fork, gas is capped at all but one 64th (remaining_gas / 64) of the remaining gas of the current context. If a call tries to send more, the gas is changed to match the maxiumum allowed.",
    "input": {
      "gas": "amount of gas to send to the sub context to execute. The gas that is not used by the sub context is returned to this one.",
      "address": "the account which code to execute.",
      "argsOffset": "byte offset in the memory in bytes, the calldata of the sub context.",
      "argsSize": "byte size to copy (size of the calldata).",
      "retOffset": "byte offset in the memory in bytes, where to store the return data of the sub context.",
      "retSize": "byte size to copy (size of the return data)."
    },
    "output": {
      "success": "return 0 if the sub context reverts, 1 otherwise."
    }
  },
  {
    "opcode": "F5",
    "name": "CREATE2",
    "mingas": "32000",
    "since": "constantinople",
    "group": "systemops",
    "notes": "Equivalent to CREATE, except the salt allows the new contract to be deployed at a consistent, deterministic address.\n\nShould deployment succeed, the account's code is set to the return data resulting from executing the initialization code.\n\nThe destination address is calculated as follows:\n\ninitialization_code=memory[offset:offset_size]\naddress = keccak256(0xff + sender_address + salt + keccak256(initialization_code))[12:]\n\nDeployment can fail due to:\n\nA contract already exists at the destination\nInsufficient value to transfer.\nSub context reverted.\nInsufficient gas to execute the initialization code.\nCall depth limit reached.\n\nNote that these failures only affect the return value and do not cause the calling context to revert (unlike the error cases below).",
    "input": {
      "value": "value in wei to send to the new account.",
      "offset": "byte offset in the memory in bytes, the initialization code of the new account.",
      "size": "byte size to copy (size of the initalization code).",
      "salt": "32-byte value used to create the new account at a deterministic address."
    },
    "output": {
      "address": "the address of the deployment contract, 0 if the deployment failed."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current execution context is from a STATICCALL."
  },
  {
    "opcode": "FA",
    "name": "STATICCALL",
    "mingas": "100",
    "since": "homestead",
    "group": "systemops",
    "notes": "Creates a new sub context and executes the code of the given account, then resumes the current one. Note that an account with no code will return success as true (1).\n\nThis instruction is equivalent to CALL, except that it does not allow any state modifying instructions or sending ETH in the sub context. The disallowed instructions are CREATE, CREATE2, LOG0, LOG1, LOG2, LOG3, LOG4, SSTORE, SELFDESTRUCT, and CALL if the value sent is not 0.\n\nIf the size of the return data is not known, it can also be retrieved after the call with the instructions RETURNDATASIZE and RETURNDATACOPY (since the Byzantium fork).\n\nFrom the Tangerine Whistle fork, gas is capped at all but on 64th (remaining_gas / 64) of the remaining gas of the current context. If a call tries to send more, the gas is changed to match the maximum allowed.",
    "input": {
      "gas": "amount of gas to send to the sub context to execute. The gas that is not used by the sub context is returned to this one.",
      "address": "the account which context to execute.",
      "argsOffset": "byte offset in the memory in bytes, the calldata of the sub context.",
      "retOffset": "byte offset in the memory in bytes, where to store the return data of the sub context.",
      "retSize": "byte size to copy (size of the return data)."
    },
    "output": {
      "success": "return 0 if the sub context reverts, 1 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "static_gas": "0",
      "dynamic_gas": "memory_expansion_cost + code_execution_cost + address_access_cost",
      "notes": "the different costs are:\n\ncode_exeuction_cost is the cost of the called code execution (limited by the gas parameter).\nIf the address is warm, the address_access_cost is 100, otherwise it is 2600."
    }
  },
  {
    "opcode": "FD",
    "name": "REVERT",
    "mingas": "0",
    "since": "byzantium",
    "group": "systemops",
    "notes": "Stops the current context execution, revert the state changes (see STATICCALL and list the state changing opcodes) and return the unused gas to the caller. It also reverts the gas refund to its value before the current context. If the execution is stopped with REVERT, the value 0 is put on the stack of the calling context, which continues to execute normally. The return data of the calling context is set as the given chunk of memory of this context.",
    "input": {
      "offset": "byte offset in the memory in bytes. The return data of the calling context.",
      "size": "byte size to copy (size of the return data)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "FE",
    "name": "INVALID",
    "mingas": "NaN",
    "since": "homestead",
    "group": "systemops",
    "notes": "Equivalent to any other opcode not present in this reference, but guaranteed to remain an invalid instruction. Equivalen to REVERT (since Byzantium fork) with 0,0 as stack parameters, except that all the gas given to current context is consumed."
  },
  {
    "opcode": "FF",
    "name": "SELFDESTRUCT",
    "mingas": "5000",
    "since": "frontier",
    "group": "systemops",
    "notes": "The current account is registered to be destroyed, and will be at the end of the current transaction. The transfer of the current balance to the given account cannot fail. In particular, the destination account code (if any) is not executed, or, if the account does not exist, the balance is still added to the given address.",
    "input": {
      "address": "account to send the current balance (see BALANCE or SELFBALANCE since Istanbul fork)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nThe current execution context is from a STATICCALL (since Byzantium fork)."
  }
]