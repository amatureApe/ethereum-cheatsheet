[
  {
    "opcode": "00",
    "name": "STOP",
    "mingas": "0",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "Exits the current context successfully.\n\nWhen a call is executed on an address with no code and the EVM tries to read the code data, the default value is returned, 0, which corresponds to the this instruction and halts the execution."
  },
  {
    "opcode": "01",
    "name": "ADD",
    "mingas": "3",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "first integer value to add",
      "b": "second integer value to add"
    },
    "output": {
      "a + b": "integer result of the addition modulo 2^256."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "02",
    "name": "MUL",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "first integer value to multiply.",
      "b": "second integer value to multiply."
    },
    "output": {
      "a * b": "integer result of the multiplication modulo 2^256."
    },
    "errors": "The state changes done by the current context are reverted int he following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "03",
    "name": "SUB",
    "mingas": "3",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "first integer value.",
      "b": "integer value to subtract from the first."
    },
    "output": {
      "a - b": "integer result of the subtraction modulo 2^256"
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "04",
    "name": "DIV",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a / b": "integer result of the integer division. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "05",
    "name": "SDIV",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All values are treated as two's complement signed 256-bit integers. Note the overflow semantic when -2^256 is negated.",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a / b": "integer result of the signed integer division. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "06",
    "name": "MOD",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a % b": "integer result of the integer modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "07",
    "name": "SMOD",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All values are treated as two's complement signed 256-bit integers. Note the overflow semantic when -2^256 is negated.",
    "input": {
      "a": "integer numerator.",
      "b": "integer denominator."
    },
    "output": {
      "a % b": "integer result of the signed integer modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "08",
    "name": "ADDMOD",
    "mingas": "8",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All intermediate calculations of this operation are not subject to the 2^256 modulo.",
    "input": {
      "a": "first integer value to add.",
      "b": "second integer value to add.",
      "N": "integer denominator."
    },
    "output": {
      "(a + b) % N": "integer result of the addition followed by a modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "09",
    "name": "MULMOD",
    "mingas": "8",
    "since": "frontier",
    "group": "stop&arithmetic",
    "notes": "All intermediate calculations of this operation are not subject to the 2^256 modulo.",
    "input": {
      "a": "the first integer value to multiply.",
      "b": "second integer value to multiply.",
      "N": "integer denominator."
    },
    "output": {
      "(a * b) % N": "integer result of the multiplication followed by a modulo. If the denominator is 0, the result will be 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "0A",
    "name": "EXP",
    "mingas": "10",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "a": "integer base.",
      "b": "integer exponent."
    },
    "output": {
      "a ** b": "integer result of the exponential operation modulo 2^256."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "OB",
    "name": "SIGNEXTEND",
    "mingas": "5",
    "since": "frontier",
    "group": "stop&arithmetic",
    "input": {
      "b": "size in byte -1 of the integer to sign extend.",
      "x": "integer value to sign extend."
    },
    "output": {
      "y": "integer result of the sign extend."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "10",
    "name": "LT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "left side integer.",
      "b": "right side integer."
    },
    "output": {
      "a < b": "1 if the left side is smaller, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "11",
    "name": "GT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "left side integer.",
      "b": "right side integer."
    },
    "output": {
      "a > b": "1 if the left side is bigger, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "12",
    "name": "SLT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "notes": "All values are treated as two's complement signed 256-bit integers.",
    "input": {
      "a": "left side signed integer",
      "b": "right side signed integer."
    },
    "output": {
      "a < b": "1 if the left side is smaller, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "13",
    "name": "SGT",
    "mingas": "6",
    "since": "frontier",
    "group": "comparison&bitwise",
    "notes": "All values are treated as two's complements signed 256-bit integers.",
    "input": {
      "a": "left side signed integer.",
      "b": "right side signed integer."
    },
    "output": {
      "a < b": "1 if the left side is bigger, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "14",
    "name": "EQ",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "left side integer.",
      "b": "right side integer."
    },
    "output": {
      "a == b": "1 if the left side equal to the right side, 0 otherwise"
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "15",
    "name": "ISZERO",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "integer."
    },
    "output": {
      "a == 0": "1 if a is 0, 0 otherwise."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "16",
    "name": "AND",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "first brinary value.",
      "b": "second binary value."
    },
    "output": {
      "a & b": "the bitwise AND result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "17",
    "name": "OR",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "first brinary value.",
      "b": "second binary value."
    },
    "output": {
      "a | b": "the bitwise OR result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "18",
    "name": "XOR",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "first brinary value.",
      "b": "second binary value."
    },
    "output": {
      "a ^ b": "the bitwase XOR result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "19",
    "name": "NOT",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "a": "binary value."
    },
    "output": {
      "~a": "the bitwase NOT result."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "1A",
    "name": "BYTE",
    "mingas": "3",
    "since": "frontier",
    "group": "comparison&bitwise",
    "input": {
      "i": "byte offset starting from the most significant bytes.",
      "x": "32-bytes value."
    },
    "output": {
      "y": "the indicated bytes at the least significant position. If the bytes offset is out of range, the result is 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "1B",
    "name": "SHL",
    "mingas": "3",
    "since": "constantinople",
    "group": "comparison&bitwise",
    "notes": "Shift the bits towards the most significant one. The bits moved after the 256th one are discarded, the new bits are set to 0.",
    "input": {
      "shift": "number of bits to shift to the left.",
      "value": "32 bytes to shift."
    },
    "output": {
      "value << shift": "the shifted value. If shift is bigger than 255, returns 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "1C",
    "name": "SHR",
    "mingas": "3",
    "since": "constantinople",
    "group": "comparison&bitwise",
    "notes": "Shifts the bit towards the least significant one. The bits moved before the first one are discarded, the new bits are set to 0.",
    "input": {
      "shift": "number of bits to shift to the right.",
      "value": "32 bytes to shift."
    },
    "output": {
      "value >> shift": "the shifted value. If shift is bigger than 255, returns 0."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcodes": "1D",
    "name": "SAR",
    "mingas": "3",
    "since": "constantinople",
    "group": "comparison&bitwise",
    "notes": "Shift the bits towards the least significant one. The bits moved before the first one are discarded, the new bits are set to 0 if the previous most significant bit was 0, otherwise the new bits are set to 1.",
    "input": {
      "shift": "number of bits to shift to the right.",
      "value": "integer to shift."
    },
    "output": {
      "value >> shift": "the shifted value."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "20",
    "name": "SHA3",
    "mingas": "30",
    "since": "frontier",
    "group": "SHA3",
    "input": {
      "offset": "byte offset in the memory.",
      "size": "byte size to read in the memory."
    },
    "output": {
      "hash": "Keccak-256 hash of the given data in memory."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "30",
      "dynamic_gas": "6 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "30",
    "name": "ADDRESS",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "address": "the 20-byte address of the current account."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "31",
    "name": "BALANCE",
    "mingas": "100",
    "since": "frontier",
    "group": "environmentalinfo",
    "input": {
      "address": "the 20-byte address of the current account."
    },
    "output": {
      "balance": "balance of the given account in wei. Returns 0 if the account doesn't exist."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": "The static cost is 0. if the accessed address is warm, the dynamic cost is 100. Otherwise the dynamic cost is 2600."
  },
  {
    "opcode": "32",
    "name": "ORIGIN",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "address": "the 20-byte address of the sender of the transaction. It can only be an account without code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "33",
    "name": "CALLER",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "address": "the 20-byte address of the caller account. This is the account that did the last call (except delegate call)."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "34",
    "name": "CALLVALUE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "value": "the value of the current call in wei."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "35",
    "name": "CALLDATALOAD",
    "mingas": "3",
    "since": "frontier",
    "group": "environmentalinfo",
    "input": {
      "i": "byte offset in the calldata."
    },
    "output": {
      "data[i]": "32-byte value starting from the given offset of the calldata. All bytes after end of the calldata are set to 0."
    },
    "gas": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "36",
    "name": "CALLDATASIZE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "size": "byte size of the calldata."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "37",
    "name": "CALLDATACOPY",
    "mingas": "3",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "For out of bound bytes, 0s will be copied",
    "input": {
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the calldata to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "3",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "38",
    "name": "CODESIZE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "Each instruction occupies on byte. In the case of a PUSH instruction, the bytes that need to be pushed are encoded after that, it thus increases the codesize accordingly.",
    "output": {
      "size": "byte size of the code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "39",
    "name": "CODECOPY",
    "mingas": "3",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "For out of bounds bytes, 0s will be copied.",
    "input": {
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the code to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "3",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "3A",
    "name": "GASPRICE",
    "mingas": "2",
    "since": "frontier",
    "group": "environmentalinfo",
    "output": {
      "price": "gas price in wei per gas."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "3B",
    "name": "EXTCODESIZE",
    "mingas": "100",
    "since": "frontier",
    "group": "environmentalinfo",
    "input": {
      "address": "20-byte address of the contract to query."
    },
    "output": {
      "size": "byte size of the code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": "The static cost is 0. If the accessed address is warm, the dynamic cost is 100. Otherwise the dynamic cost is 2600."
  },
  {
    "opcode": "3C",
    "name": "EXTCODECOPY",
    "mingas": "100",
    "since": "frontier",
    "group": "environmentalinfo",
    "notes": "For out of bounds bytes, 0s will be copied.",
    "input": {
      "address": "20-byte address of the contract to query.",
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the code to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "0",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost + address_access_cost",
      "notes": "If the accessed address is warm, address_access_cost is 100, otherwise it is 2600."
    }
  },
  {
    "opcode": "3D",
    "name": "RETURNDATASIZE",
    "mingas": "2",
    "since": "byzantium",
    "group": "environmentalinfo",
    "notes": "A sub context can be created with CALL, CALLCODE, DELEGATECALL, or STATICCALL",
    "output": {
      "size": "byte size of the return data from the last executed sub context."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "3E",
    "name": "RETURNDATACOPY",
    "mingas": "3",
    "since": "byzantium",
    "group": "environmentalinfo",
    "notes": "A sub context can be creaed with CALL, CALLCODE, DELEGATECALL, or STATICCALL.",
    "input": {
      "destOffset": "byte offset in the memory where the result will be copied.",
      "offset": "byte offset in the return data from the last executed sub context to copy.",
      "size": "byte size to copy."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.\nReading offset equal or higher than RETURNDATASIZE.",
    "gas": {
      "minimum_word_size": "(size + 31) / 32",
      "static_gas": "3",
      "dynamic_gas": "3 * minimum_word_size + memory_expansion_cost"
    }
  },
  {
    "opcode": "3F",
    "name": "EXTCODEHASH",
    "mingas": "100",
    "since": "constantinople",
    "group": "environmentalinfo",
    "input": {
      "address": "20-byte address of the account."
    },
    "output": {
      "hash": "hash of the chosen account's code, or 0 if the account has no code."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack.",
    "gas": "The static cost is 0. If the accessed address is warm, the dynamic cost is 100. Otherwise the dynamic cost is 2600."
  },
  {
    "opcode": "40",
    "name": "BLOCKHASH",
    "mingas": "20",
    "since": "frontier",
    "group": "blockinfo",
    "input": {
      "blockNumber": "block number to get the hash from. Valid range is the last 256 blocks (not including the current one). Current block number can be queried with NUMBER."
    },
    "output": {
      "hash": "hash of the chosen block, or 0 if the block number is not in the valid range."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nNot enough values on the stack."
  },
  {
    "opcode": "41",
    "name": "COINBASE",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "address": "miner's 20-byte address."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "42",
    "name": "TIMESTAMP",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "timestamp": "unix timestamp of the current block"
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  },
  {
    "opcode": "43",
    "name": "NUMBER",
    "mingas": "2",
    "since": "frontier",
    "group": "blockinfo",
    "output": {
      "blockNumber": "current block number."
    },
    "errors": "The state changes done by the current context are reverted in the following cases:\n\nNot enough gas.\nStack overflow."
  }
]